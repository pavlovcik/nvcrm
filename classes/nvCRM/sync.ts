import nvCRM from ".";
import Proposal from '../../types/Proposal';
import downloadAll from "./getParallel";
import Project from "../../types/Project";
import compileProposal from './compileProposal';

/**
 *
 * This simply selects and returns the correct storage adapter
 * upon initialization of nvCRM in order to properly handle the different storage conditions
 * based on the execution environment, which can be either one of the following:
 * the browser, nodejs, and possibly Google Drive.
 *
 */

export default class SyncEngine {   //  @TODO: damn this needs organization!!

    public store: Function;
    // public proposal: Proposal;
    public resolve = function resolver(a: Proposal, b: Proposal): Proposal {

        /**
         * This simply needs to compare timestamps between competing copies of the data.

         * It should ideally check three properties in each argument:
         *  1. proposal.meta.updated    //  maybe?
         *  2. proposal.account.meta.updated
         *  3. proposal.project.meta.updated
         *
         * Then it should recompile the latest information and sync to the server/Drive.
         * This same function should be used by server/Drive to reconcile the latest data.
         */

        return new Date(a.meta.updated) > new Date(b.meta.updated) ? a : b // @TODO: only does 1. now.


    };
    // public push: Promise<void> = async function pusher(): Promise<void> { };

    public pull = async function puller(...urls: string[]) {
		/**
		 * Pass in any URLs, and this should figure out what data it is working with based on meta.type's property value.
		 *
		 * This should be able to handle the following types: Account, Project and Proposal
		 */
        interface Identified {
            account?: Account[];
            project?: Project[];
            proposal?: Proposal[];
        };

        // nvCRM.proposal =
        return await downloadAll(...urls)
            .then(identify)
            .then(organize)
            .then((proposal: Proposal) => compileProposal(proposal.account, proposal.project))  //  @FIXME: awkward
            .then(this.store);

        function identify(responses: any[]) {	//	@TODO: should be broken up into its own module under SyncEngine

            /**
             * Check the metadata for its type and understand what was just received.
             * Then add to an array so that the modified time can be considered for resolving
             */

            let identified: Identified = {};
            let unexpected = {};	//	We were able to read the object.meta.type but it wasn't "account", "project", or "proposal"
            responses.forEach(parser);
            return { identified, unexpected }

            function parser(object: any) {
                if (object.meta) {
                    let type = object.meta.type;
                    if (type) {
                        if (type === "project" || type === "account" || type === "proposal") {
                            if (!identified[type]) identified[type] = [object];
                            else identified[type].push(object)
                        } else {
                            if (!unexpected[type]) unexpected[type] = [object];
                            else unexpected[type].push(object)
                        }
                    }
                }
            }

        }
        function organize(input: { identified: Identified, unexpected: any }): Proposal {		//	@TODO: should be broken up into its own module under SyncEngine

            // Compile the Proposal object based on the inputs.

            /**
             * This should produce a { Proposal } object and intelligently consider the different times of different updated components.
             *
             * It should be able to handle receiving the following object types: { Proposal }, { Account }, { Project }, { any }
             * *	and reject { any }
             * *	and give weight to the { Project } being the most likely to be updated the most frequently,
             * * *	then { Account }
             * * *	then { Proposal } (because this is usually generated by software instead of actual human input)
             *
             * This should use the SyncEngine.resolver() ???
             * This seems too tightly coupled with business logic only using queue.identified and should be further abstracted for reusability @TODO: handle queue.unexpected
             *
             */

            let output = {
                meta: null, project: null, account: null    //  @TODO: meta needs to be generated lol
            };

            if (input.identified.proposal) {
                output = input.identified.proposal.shift()	//	@TODO: lazy right now so picking first one, but should loop through and consider timestamps.
            }
            if (input.identified.account) {
                output.account = input.identified.account.shift()	//	@TODO: lazy right now so picking first one, but should loop through and consider timestamps.
            }
            if (input.identified.project) {
                output.project = input.identified.project.shift()	//	@TODO: lazy right now so picking first one, but should loop through and consider timestamps.
            }

            if (!output.project) throw new Error(`Project information missing.`);
            if (!output.account) throw new Error(`Account information missing.`);

            return output

        }

    }

    public push = async function pusher(): Promise<any> {   //  @TODO: design API response.

        /**
         * If this is browser, push to node.
         * If this is node, push to drive.
         * If this is drive, push to node. @TODO: ?
         *
         */

    }

    constructor(nvCRM: nvCRM) {  //  adapter selection upon construction
        this.store = this.adapter[nvCRM.environment](nvCRM)  // selected adapter
    }


    private adapter = {

        browser(nvCRM: nvCRM) {
            /*... understands how to work with localStorage */
            return function storage(proposal: Proposal) {
                localStorage[window.location.pathname] = JSON.stringify(proposal);
                return JSON.parse(localStorage[window.location.pathname]);
            }
        },
        node(nvCRM: nvCRM) {
            /*... understands how to work with JSON file storage and fs.write */
            return function storage(index: string) {
                return null
            }
        },
        drive(nvCRM: nvCRM) {
            /*... understands how to work with DriveApp.Folder, DriveApp.File etc. Might have to be async which could be interesting.  */
            return function storage(index: string) {
                return null
            }
        }

    }

}
