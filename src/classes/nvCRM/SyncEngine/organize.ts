import Proposal from "../../../types/Proposal";
import { Identified } from "./identify";

export default function organize(input: { identified: Identified, unexpected: any }): Proposal {

    // Compile the Proposal object based on the inputs.

    /**
     * This should produce a { Proposal } object and intelligently consider the different times of different updated components.
     *
     * It should be able to handle receiving the following object types: { Proposal }, { Account }, { Project }, { any }
     * *	and reject { any }
     * *	and give weight to the { Project } being the most likely to be updated the most frequently,
     * * *	then { Account }
     * * *	then { Proposal } (because this is usually generated by software instead of actual human input)
     *
     * This should use the SyncEngine.resolver() ???
     * This seems too tightly coupled with business logic only using queue.identified and should be further abstracted for reusability @TODO: handle queue.unexpected
     *
     */

    let output = {
        meta: null, project: null, account: null    //  @TODO: meta needs to be generated lol
    };

    if (input.identified.proposal) {
        output = input.identified.proposal.shift()	//	@TODO: lazy right now so picking first one, but should loop through and consider timestamps.
    }
    if (input.identified.account) {
        output.account = input.identified.account.shift()	//	@TODO: lazy right now so picking first one, but should loop through and consider timestamps.
    }
    if (input.identified.project) {
        output.project = input.identified.project.shift()	//	@TODO: lazy right now so picking first one, but should loop through and consider timestamps.
    }

    if (!output.project) throw new Error(`Project information missing.`);
    if (!output.account) throw new Error(`Account information missing.`);

    return output

}