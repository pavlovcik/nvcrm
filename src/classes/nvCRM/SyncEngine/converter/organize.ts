import { Identified } from "./identify";
import resolve from "./resolver";
import Proposal from "../../../../types/Proposal";
import Account from "../../../../types/Account";
import Project from "../../../../types/Project";


let latest = (a: Account, b: Account): number => {
    const A = new Date(a.meta.updated);
    const B = new Date(b.meta.updated);
    if (A > B) return -1
    else if (A < B) return 1
    else return 0
};

export default function organize( input: { identified: Identified, unexpected: any } ): Proposal {

    // @FIXME: this function has really weird interfaces.

    // Compile the Proposal object based on the inputs.

    /**
     * This should produce a { Proposal } object and intelligently consider the different times of different updated components.
     *
     * It should be able to handle receiving the following object types: { Proposal }, { Account }, { Project }, { any }
     * *	and reject { any }
     * *	and give weight to the { Project } being the most likely to be updated the most frequently,
     * * *	then { Account }
     * * *	then { Proposal } (because this is usually generated by software instead of actual human input)
     *
     * This should use the SyncEngine.resolver() ???
     * This seems too tightly coupled with business logic only using queue.identified and should be further abstracted for reusability @TODO: handle queue.unexpected
     *
     */

    let iid = input.identified;

    let out = { meta: null, project: null, account: null };

    if (iid.proposal) out = iid.proposal.sort(resolve).shift()
    if (iid.account) out.account = iid.account.sort(latest).shift()
    if (iid.project) out.project = iid.project.sort(latest).shift()

    if (!out.project) {
        // @TODO: work with the unexpected inputs here
        console.error(`Project information missing.`);
        // debugger;
    }
    if (!out.account) {
        // @TODO: work with the unexpected inputs here
        console.error(`Account information missing.`);
        // debugger;
    }

    // if (!output.project) throw new Error(`Project information missing.`);
    // if (!output.account) throw new Error(`Account information missing.`);

    return out

}