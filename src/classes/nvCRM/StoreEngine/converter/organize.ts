
/**
 * This is supposed to be able to accept any data type <MetaDataTypesAsInterfaces> and build up
 * a proposal from all of it. It will choose the latest timestamped piece of data from each type.
 *
 * @TODO: phases for engineering:
 *
 *      1: Take { Proposal } and roll with it
 *      2. Merge { Account } and { Project } ... to generate { Proposal }
 *      3. Merge { Client } to { Account } to { Project } ...
 *      4. Merge { Service } to { Project }
 *      5. Merge { Deliverable } to { Service }
 *
 *                      Deliverable[]
 *                              v
 *                           Service[]
 *                                v
 *                              Project   >   Proposal
 *                                ^
 *                         Account
 *                              ^
 *                        Client
 *
 *  WEIGHTS
 *
 * { Project } being the most likely to be updated the most frequently,
 * * *	then { Account }
 * * *	then { Proposal } (because this is usually generated by software instead of actual human input)
 *
 */

/**
 * This should produce a { Proposal } object and intelligently consider the different times of different updated components.
 */

import Proposal from "../../../../types/Proposal";
import { Identified } from "./identify";
import resolve from "./resolver";
import Meta, { MetaDataTypesAsInterfaces, MetaDataTypesAsStrings } from "../../../../types/Meta";
import Client from "../../../../types/Client";
import Project from "../../../../types/Project";
import Service from "../../../../types/Service";
import compile from "./compile";

let getLatest = (o: MetaDataTypesAsInterfaces[]):
    MetaDataTypesAsInterfaces | undefined =>
    o.sort(sortingByMostRecent).shift();

// interface Latest { client: Client | undefined; proposal: Proposal | undefined; account: Account | undefined; project: Project | undefined; service: Service | undefined; }

export default function organize(input: { identified: Identified, unexpected: any }): Proposal {
    let latestValues = { client: undefined, proposal: undefined, account: undefined, project: undefined, service: undefined, meta: undefined };
    let identifiedEntries = Object.entries(input.identified);
    let x = identifiedEntries.length;
    while (x--) {
        let entry = identifiedEntries[x];
        let key = entry[0] as MetaDataTypesAsStrings;
        latestValues[key] = getLatest(input.identified[key])
    }
    let proposal: Proposal = latestValues.proposal ? latestValues.proposal : compile(latestValues)
    return proposal //  @TODO: not sure if sufficient

    // function chooseAccount(options: any) { return options.account }
    // function chooseProject(options: any) { return options.project }
}

function clobberWithAccount({ input, constructing, preload_PROPOSAL }) {
    let account = input.identified.account.sort(sortingByMostRecent).shift();
    const preload_ACCOUNT = new Date(account?.meta?.updated || 0);
    if (
        preload_PROPOSAL < preload_ACCOUNT &&
        new Date(constructing?.account?.meta?.updated || 0) < preload_ACCOUNT
    ) {
        return account
    } else {
        return constructing
    }
    // @TODO: test if it really is outputting the latest.
}

function clobberWithProject({ input, constructing, preload_PROPOSAL }) {
    let project = input.identified.project.sort(sortingByMostRecent).shift();
    const preload_PROJECT = new Date(project?.meta?.updated || 0);
    if (
        preload_PROPOSAL < preload_PROJECT &&
        new Date(constructing?.project?.meta?.updated || 0) < preload_PROJECT
    ) {
        return project
    } else {
        return constructing
    }

    // @TODO: test if it really is outputting the latest.
}

function sortingByMostRecent(a: MetaDataTypesAsInterfaces, b: MetaDataTypesAsInterfaces): number {
    const A = new Date(a.meta.updated);
    const B = new Date(b.meta.updated);
    if (A > B) return -1
    else if (A < B) return 1
    else return 0
};
